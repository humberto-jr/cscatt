/******************************************************************************

 AUTHOR
 ======

 Written by Humberto Jr, 2018-2019
 Last modified: Jul 02, 2019


 ABOUT
 =====

 This module is a collection of routines designed to solve problems related to
 atomic and molecular scattering. It includes general-purpose functions to man
 ipulate files, pointers, linear algebra, several types of data structures and
 physics.

 All written in C (C99 standard) and the main dependency is the GNU Scientific
 Library (GSL).

 Atomic units are used through unless explicitly stated otherwise.


 HOW TO BUILD
 ============

 Suppose a C compiler CC (e.g. CC=gcc or CC=icc) and a GSL installation in the
 path given by GSLROOT (e.g. GSLROOT=/usr/local),

 $CC -W -Wall -std=c99 -pedantic -fopenmp -O3 -I$GSLROOT/include -c filename.c

 is a fairly general method to compile the module, and it is relatively simple
 to adapt for a given choice of CC. Specifying the C standard and pedantic opt
 ion is always recommended in order to avoid the use of C++ rules and others C
 specifications.

 Some optional macros are available to tune the compilation:

 USE_MKL              = switch on the use of Intel Math Kernel Library.
 USE_ESSL             = switch on the use of IBM Engineering and Scientific
                        Subroutine Library.
 USE_LAPACKE          = switch on the use of LAPACKE library.
 USE_DUMMY_PES        = switch off the use of an user defined PES routine.
 MAX_LINE_LENGTH      = maximum length of all strings used in the module.
 GSL_MAX_WORKSPACE    = maximum number of elements used in all GSL workspace.
 USE_NON_REACTIVE_PES = uses Jacobi coordinates instead of internuclear dista
                        nces when invoking the user defined PES routine.

 Often, the compiler option used to define macros is -D, e.g.

 -DUSE_MKL -DUSE_NON_REACTIVE_PES

 Thus, check out the documentation of your choice of CC.


 NAMING CONVENTION
 =================

 pes        = potential energy surface.
 pec        = potential energy curve.
 grid_size  = number of points in a grid mesh.
 grid_step  = step of a given variable in a grid.
 input      = a FILE object open with mode = 'r' (read only).
 output     = a FILE object open with mode = 'w' (write only).
 max_row    = maximum number of rows (matrices, data files etc).
 max_col    = maximum number of columns (matrices, data files etc).
 max_ch     = maximum number of (scattering) channels.
 ch         = (scattering) channel.
 wavef      = wavefunction.
 arrang     = arrangement; 'a' for A+BC, 'b' for B+CA, 'c' for C+AB etc.
 eigenvec   = eigenvector.
 eigenval   = eigenvalue.
 spin_mult  = spin multiplicity; 1 for singlet, 2 for doublet etc.
 pot_energy = potential energy (sometimes named v).
 kin_energy = kinetic energy.
 tot_energy = total energy.
 use_omp    = switch on/off the use of OpenMP.
 wavenum    = wavenumber; sqrt(2.0*mass*E), where E = E_tot - V(inf).


 DEV NOTES
 =========

 1) Variables are set const whenever possible, for the sake of correctness.

 2) Due to (1), on exit, all non-const input parameters are necessarily
    modified and/or output.

 3) On entry, all input representing sizes and pointers are always checked.
    The use of size_t types is not recommended.

 4) Maximum length for strings is given by the macro MAX_LINE_LENGTH.

 5) Matrices are always ordinary vectors with elements stored in a row-major
    scheme: vector[n*max_col + m], where n = [0, max_row) and m = [0, max_col).

 6) Priority for efficiency. However complicated algorithms are sometimes
    written in a non-efficient approach, provided the resulting code is
    more readble and error-free.

 7) The use of OpenMP in this module (often, use_omp = true) implies it is not
    used anywhere else, including the external linear algebra libraries.

 8) This module is thread-safe intended.


 REFERENCES
 ==========

 [1] M. Hernandez Vera et al. J. Chem. Phys. 146, 124310 (2017)
     doi: https://doi.org/10.1063/1.4978475

 [2] R. T. Pack J. Chem. Phys. 60, 633 (1974)
     doi: https://doi.org/10.1063/1.1681085

 [3] O. Dulieu et al. J. Chem. Phys. 103 (1) (1995)
     doi: 10.1063/1.469622

 [4] B. R. Johnson J. Chem. Phys. 69, 4678 (1978)
     doi: https://doi.org/10.1063/1.436421

 [5] V. Kokoouline et al. J. Chem. Phys. 110, 20 (1999)
     doi:

 [6] W. H. Miller. J. Chem. Phys. 1, 50 (1969)
     doi:

 [7] R. B. Bernstein et al. Proc. R. Soc. Lond. A 1963 274 , 427-442
     doi: https://doi.org/10.1098/rspa.1963.0142

 [8] A. E. DePristo et al. J. Phys. B: Atom. Molec. Phys., Vol. 9, No. 3 (1976)
     doi:

 [9] D. D. Lopez-Duran et al. Com. Phys. Comm. 179 (2008) 821-838
     doi: https://doi.org/10.1016/j.cpc.2008.07.017

 [10] B. R. Johnson J. Comp. Phys. 13, 445-449 (1973)
      doi: https://doi.org/10.1016/0021-9991(73)90049-1

 [11] B. R. Johnson J. Chem. Phys. 67, 4086 (1977)
      doi: https://doi.org/10.1063/1.435384

 [12] M. Monnerville et al. J. Chem. Phys. 101, 7580 (1994)
      doi: http://dx.doi.org/10.1063/1.468252

 [13] R. E. Olson et al. Phys. Rev. A. 3, 1607 (1971)
      doi: https://doi.org/10.1103/PhysRevA.3.1607

 [14] B. R. Johnson. J. Comp. Phys. 13, 445 (1973)
      doi: https://doi.org/10.1016/0021-9991(73)90049-1

 [15] John C. Tully. J. Chem. Phys. 93, 1061 (1990)
      doi: http://dx.doi.org/10.1063/1.459170

******************************************************************************/

#include <omp.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#include <gsl/gsl_math.h>
#include <gsl/gsl_sf_bessel.h>

#include "globals.h"
#include "johnson.h"
#include "matrix.h"

/******************************************************************************

 Function johnson_riccati_bessel(): returns the Riccati-Bessel function J(l, x)
 if type = 'j', or N(l, x) if type = 'n', as defined in Eq. (14) and (15) of
 Ref. [10]. These are made upon spherical Bessel functions, j(l, x) and
 y(l, x).

******************************************************************************/

double johnson_riccati_bessel(const char type, const int l,
                              const double wavenum, const double x)
{
	switch (type)
	{
		case 'j': return  (wavenum*x)*gsl_sf_bessel_jl(l, wavenum*x)/sqrt(wavenum);
		case 'n': return -(wavenum*x)*gsl_sf_bessel_yl(l, wavenum*x)/sqrt(wavenum);

		default: return 0.0;
	}
}

/******************************************************************************

 Function johnson_modif_spher_bessel(): returns the modified spherical Bessel
 functions J(l, x) if type = 'j', or N(l, x) if type = 'n', as defined in Eq.
 (16) and (17) of Ref. [10]. These are made upon regular and irregular
 modified spherical Bessel functions, i(l, x) and k(l, x).

******************************************************************************/

double johnson_modif_spher_bessel(const char type, const int l,
                                  const double wavenum, const double x)
{
	switch (type)
	{
		case 'j': return sqrt(wavenum*x)*gsl_sf_bessel_il_scaled(l, wavenum*x);
		case 'n': return sqrt(wavenum*x)*gsl_sf_bessel_kl_scaled(l, wavenum*x);

		default: return 0.0;
	}
}

/******************************************************************************

 Function johnson_jcp77_numerov(): use the method of B. R. Johnson, Ref. [11],
 to construct the single channel wavefunction at a given trial energy. The
 return pointer contains the unormalized amplitude at grid_size points.

 NOTE: on exit, a negative number of nodes implies that no matching point has
 been found (see Ref. [11]).

******************************************************************************/

double *johnson_jcp77_numerov(const int grid_size,
                              const double grid_step,
                              const double pot_energy[],
                              const double trial_energy,
                              const double mass,
                              double *error,
                              int *nodes)
{
	ASSERT(grid_size > 0)
	ASSERT(pot_energy != NULL)

	double *T = allocate(grid_size, false);
	double *F = allocate(grid_size, false);

	double *inward_R  = allocate(grid_size, false);
	double *outward_R = allocate(grid_size, false);

/*
 *	Solve Eq. (32), (35) and (46) for each T, U and R (inward) coefficient:
 */

	inward_R[grid_size - 1] = 1.0E20;

	T[grid_size - 1] =
		-pow(grid_step, 2)*2.0*mass*(trial_energy - pot_energy[grid_size - 1])/12.0;

	int M = 0;
	for (int n = (grid_size - 2); n > -1; --n)
	{
		T[n] = -pow(grid_step, 2)*2.0*mass*(trial_energy - pot_energy[n])/12.0;
		inward_R[n] = (2.0 + 10.0*T[n])/(1.0 - T[n]) - 1.0/inward_R[n + 1];

/*
 *		Check if the matching point, M, is found:
 */

		if (inward_R[n] <= -1.0)
		{
			M = n;
			break;
		}
	}

	if (M == 0)
	{
		free(T);
		free(F);
		free(inward_R);
		free(outward_R);

		*error =  1.0E20;
		*nodes = -1;
		return NULL;
	}

/*
 *	Solve Eq. (32), (35) and (37) for each T, U and R (outward) coefficient:
 */

	outward_R[0] = 1.0E20;

	T[0] = -pow(grid_step, 2)*2.0*mass*(trial_energy - pot_energy[0])/12.0;

	*nodes = 0;
	for (int n = 1; n < M; ++n)
	{
		T[n] = -pow(grid_step, 2)*2.0*mass*(trial_energy - pot_energy[n])/12.0;
		outward_R[n] = (2.0 + 10.0*T[n])/(1.0 - T[n]) - 1.0/outward_R[n - 1];

/*
 *		Count the number of nodes in the wavefunction:
 */

		if (outward_R[n] < 0.0) ++(*nodes);
	}

/*
 *	Solve Eq. (36) and (45) for each F coefficient:
 */

	F[M] = 1.0;
	for (int n = (M - 1); n > -1; --n)
	{
		F[n] = F[n + 1]/outward_R[n];
	}

	for (int n = (M + 1); n < grid_size; ++n)
	{
		F[n] = F[n - 1]/inward_R[n];
	}

/*
 *	Solve Eq. (33) for the wavefunction (unnormalized):
 */

	double *wavef = allocate(grid_size, false);

	for (int n = 0; n < grid_size; ++n)
	{
		wavef[n] = F[n]/(1.0 - T[n]);
	}

/*
 *	Solve Eq. (48) for the difference, D (named as error here), between the
 *	left and right integrations:
 */

	*error = (0.5 - T[M + 1])*(1.0/inward_R[M + 1] - outward_R[M])/(1.0 - T[M + 1])
	       - (0.5 - T[M - 1])*(inward_R[M] - 1.0/outward_R[M - 1])/(1.0 - T[M - 1]);

	*error *= (1.0 - T[M]);

	free(T);
	free(F);
	free(inward_R);
	free(outward_R);

	return wavef;
}

/******************************************************************************

 Function johnson_jcp78_numerov(): use the method of B. R. Johnson, Ref. [4],
 to propagate the ratio matrix of a multichannel wavefunction from the radial
 grid point (n - 1) to n at a given total energy.

 NOTE: the potential matrix is used as workspace and its content is destroyed.

******************************************************************************/

void johnson_jcp78_numerov(const double grid_step, matrix *pot_energy,
                           const double tot_energy, const double mass, matrix *ratio)
{
	ASSERT(ratio != NULL)
	ASSERT(pot_energy != NULL)

	if (!matrix_null(ratio)) matrix_inv(ratio);

/*
 *	NOTE: From Eq. (2) and (17) of Ref. [4] the following numerical
 *	factor is defined in atomic units:
 */

	register const double factor
		= -grid_step*grid_step*2.0*mass/12.0;

/*
 *	Resolve Eq. (23) of Ref. [4] with Eq. (2) and (17) plugged in:
 */

	matrix *w = pot_energy;

	for (int n = 0; n < matrix_row(pot_energy); ++n)
	{
		register double t = factor*(tot_energy - matrix_get(pot_energy, n, n));
		matrix_set(w, n, n, 1.0 - t);

		for (int m = (n + 1); m < matrix_col(pot_energy); ++m)
		{
			t = factor*(0.0 - matrix_get(pot_energy, n, m));
			matrix_set(w, n, m, 0.0 - t);

			t = factor*(0.0 - matrix_get(pot_energy, m, n));
			matrix_set(w, m, n, 0.0 - t);
		}
	}

/*
 *	Solve Eq. (22) and (24) of Ref. [4]:
 */

	matrix_inv(w);

	for (int n = 0; n < matrix_row(pot_energy); ++n)
	{
		register double u = 12.0*matrix_get(w, n, n) - 10.0;
		matrix_set(ratio, n, n, u - matrix_get(ratio, n, n));

		for (int m = (n + 1); m < matrix_col(pot_energy); ++m)
		{
			u = 12.0*matrix_get(w, n, m);
			matrix_set(ratio, n, m, u - matrix_get(ratio, n, m));

			u = 12.0*matrix_get(w, m, n);
			matrix_set(ratio, m, n, u - matrix_get(ratio, m, n));
		}
	}

	w = NULL;
}

/******************************************************************************

 Function johnson_jcp73_logd(): use the algorithm of B. R. Johnson, Ref. [14],
 in order to propagate the multichannel log derivative matrix, Y, from the
 radial grid point (n - 1) to n driven by the interaction potential V.

 NOTE: matrix V is defined as Eq. (2) of Ref. [14].

******************************************************************************/

void johnson_jcp73_logd(const int n, const int grid_size,
                        const double grid_step, const matrix *pot_energy, matrix *y)
{
	ASSERT(n > 0)
	ASSERT(y != NULL)
	ASSERT(grid_size >= n)
	ASSERT(pot_energy != NULL)
	ASSERT(GSL_IS_ODD(grid_size) == 1)

	register const int max_ch = matrix_row(pot_energy);

	/* NOTE: z[1] is the left term and u[1] is the right term of Eq. (6). */
	matrix *z = matrix_alloc(2, matrix_row(pot_energy), matrix_col(pot_energy), false);
	matrix *u = matrix_alloc(2, matrix_row(pot_energy), matrix_col(pot_energy), false);

/*
 *	Solve Eq. (7) of Ref. [14]:
 */

	if (GSL_IS_EVEN(n) == 1)
	{
		register const double weight = (n == 0? 1.0 : 2.0);
		register const double factor = grid_step*weight/3.0;

		for (int p = 0; p < matrix_row(pot_energy); ++p)
		{
			matrix_set(&z[0], p, p, 1.0 + matrix_get(y, p, p)*grid_step);
			matrix_set(&u[1], p, p, matrix_get(pot_energy, p, p)*factor);

			for (int q = (p + 1); q < matrix_col(pot_energy); ++q)
			{
				matrix_set(&z[0], p, q, 0.0 + matrix_get(y, p, q)*grid_step);
				matrix_set(&u[1], p, q, matrix_get(pot_energy, p, q)*factor);

				matrix_set(&z[0], q, p, 0.0 + matrix_get(y, q, p)*grid_step);
				matrix_set(&u[1], q, p, matrix_get(pot_energy, q, p)*factor);
			}
		}
	}
	else
	{
		register const double weight = (n == grid_size? 1.0 : 4.0);
		register const double factor = grid_step*grid_step/6.0;

		for (int p = 0; p < matrix_row(pot_energy); ++p)
		{
			matrix_set(&z[0], p, p, 1.0 + matrix_get(y, p, p)*grid_step);
			matrix_set(&u[0], p, p, 1.0 + matrix_get(pot_energy, p, p)*factor);

			for (int q = (p + 1); q < matrix_col(pot_energy); ++q)
			{
				matrix_set(&z[0], p, q, 0.0 + matrix_get(y, p, q)*grid_step);
				matrix_set(&u[0], p, q, 0.0 + matrix_get(pot_energy, p, q)*factor);

				matrix_set(&z[0], q, p, 0.0 + matrix_get(y, q, p)*grid_step);
				matrix_set(&u[0], q, p, 0.0 + matrix_get(pot_energy, q, p)*factor);
			}
		}

		matrix_inv(&u[0]);
		matrix_mul(grid_step*weight/3.0, &u[0], pot_energy, 0.0, &u[1]);
	}

	matrix_inv(&z[0]);
	matrix_mul(1.0, &z[0], y, 0.0, &z[1]);

/*
 *	Solve Eq. (6) of Ref. [14]:
 */

	matrix_sub(1.0, &z[1], 1.0, &u[1], y, matrix_row(pot_energy) > 100);

	matrix_free_all(2, z);
	matrix_free_all(2, u);
}

/******************************************************************************

 Function johnson_kmatrix(): build the augmented reactant matrix K as described
 by Eq. (A19) of Ref. [4], from the ratio matrix of the multichannel scattering
 wavefunction. Where, l and level are the asymptotic angular momentum and eigen
 value of each channel, respectively, as R -> inf.

 NOTE: both l and level are vectors with the same size of the rows (or columns)
 of the ratio matrix, i.e. total number of channels.

******************************************************************************/

matrix *johnson_kmatrix(const int l[],
                        const double grid_step,
                        const double tot_energy,
                        const double mass,
                        const double level[],
                        const matrix *ratio,
                        const double R)
{
	ASSERT(l != NULL)
	ASSERT(ratio != NULL)
	ASSERT(level != NULL)

	register const int max_ch = matrix_row(ratio);

/*
 *	NOTE: from Eq. (2) and (17) of Ref. [4] the following numerical factor is
 *	defined in atomic units:
 */

	register const double factor
		= -grid_step*grid_step*2.0*mass/12.0;

/*
 *	Step 1: build the j(R) and n(R) diagonal matrices defined by Eq. (A16) and
 *	(A17) of Ref. [4]; where, Eq. (23) is also used:
 */

	matrix *n = matrix_alloc(1, max_ch, max_ch, true);
	matrix *j = matrix_alloc(1, max_ch, max_ch, true);

	for (int i = 0; i < max_ch; ++i)
	{
		if (level[i] < tot_energy)
		{
			register const double wavenum
				= sqrt(2.0*mass*(tot_energy - level[i]));

			register const double w
				= 1.0 - factor*(tot_energy - centr_term(l[i], mass, R));

			matrix_set(n, i, i, w*johnson_riccati_bessel('n', l[i], wavenum, R));
			matrix_set(j, i, i, w*johnson_riccati_bessel('j', l[i], wavenum, R));
		}
		else
		{
			matrix_set(n, i, i, 1.0);
			matrix_set(j, i, i, 1.0);
		}
	}

/*
 *	Step 2: build the product rn and rj (r := ratio) at the grid point R, as
 *	shown in Eq. (A19) of Ref. [4]:
 */

	matrix *rn = matrix_alloc(1, max_ch, max_ch, false);
	matrix *rj = matrix_alloc(1, max_ch, max_ch, false);

	matrix_mul(1.0, ratio, n, 0.0, rn);
	matrix_mul(1.0, ratio, j, 0.0, rj);

	matrix_free(j);
	matrix_free(n);

/*
 *	Step 3: subtract j(R + grid_step) and n(R + grid_step) diagonal matrices
 *	from the rn(R) and rj(R) products, following Eq. (A19) of Ref. [4]:
 */

	for (int i = 0; i < max_ch; ++i)
	{
		register const double wavenum
			= sqrt(2.0*mass*(tot_energy - level[i]));

		register const double w_prime
			= 1.0 - factor*(tot_energy - centr_term(l[i], mass, R + grid_step));

		register const double n_prime
			= w_prime*johnson_riccati_bessel('n', l[i], wavenum, R + grid_step);

		register const double j_prime
			= w_prime*johnson_riccati_bessel('j', l[i], wavenum, R + grid_step);

		if (level[i] < tot_energy)
		{
			matrix_decr(rn, i, i, n_prime);
			matrix_decr(rj, i, i, j_prime);
		}
		else
		{
			register const double w
				= 1.0 - factor*(tot_energy - centr_term(l[i], mass, R));

			matrix_decr(rn, i, i, n_prime/(w*johnson_modif_spher_bessel('n', l[i], wavenum, R)));
			matrix_decr(rj, i, i, j_prime/(w*johnson_modif_spher_bessel('j', l[i], wavenum, R)));
		}
	}

/*
 *	Step 4: resolve Eq. (A19) of Ref. [4] for the K matrix:
 */

	matrix *k = matrix_alloc(1, max_ch, max_ch, false);

	matrix_inv(rn);
	matrix_mul(-1.0, rn, rj, 0.0, k);

	matrix_free(rn);
	matrix_free(rj);
	return k;
}

/******************************************************************************

 Function johnson_smatrix(): return both real and imaginary parts of a
 scattering matrix, S, defined as

 S := (I + iK)inv(I - iK)
    = (I - KK)inv(I + KK) + i(2K)inv(I + KK)

 Where, I is the unit matrix and K is the open-open block of a reactant matrix.

 For details see Eq. (20) of Ref. [10].

******************************************************************************/

smatrix *johnson_smatrix(const matrix *k)
{
	register const int max_ch = matrix_row(k)

	matrix *a = matrix_alloc(max_ch, max_ch, false);
	matrix *b = matrix_alloc(max_ch, max_ch, false);
	matrix *c = matrix_alloc(max_ch, max_ch, false);

/*
 *	Resolve A = KK, B = (I + A) and C = (I - A):
 */

	matrix_mul(1.0, k, k, 0.0, a);

	for (int n = 0; n < max_ch; ++n)
	{
		matrix_set(b, n, n, 1.0 + matrix_get(a, n, n));
		matrix_set(c, n, n, 1.0 - matrix_get(a, n, n));

		for (int m = (n + 1); m < max_ch; ++m)
		{
			matrix_set(b, n, m, 0.0 + matrix_get(a, n, m));
			matrix_set(b, m, n, 0.0 + matrix_get(a, m, n));

			matrix_set(c, n, m, 0.0 - matrix_get(a, n, m));
			matrix_set(c, m, n, 0.0 - matrix_get(a, m, n));
		}
	}

/*
 *	Build the S matrix, Re(S) = C*inv(B) and Im(S) = 2*K*inv(B):
 */

	matrix_inv(b);

	smatrix *s = calloc(1, sizeof(smatrix));

	s->re_part = matrix_alloc(max_ch, max_ch, false);
	s->im_part = matrix_alloc(max_ch, max_ch, false);

	matrix_mul(1.0, c, b, 0.0, s->re_part);
	matrix_mul(2.0, k, b, 0.0, s->im_part);

	matrix_free(a);
	matrix_free(b);
	matrix_free(c);
	return s;
}
